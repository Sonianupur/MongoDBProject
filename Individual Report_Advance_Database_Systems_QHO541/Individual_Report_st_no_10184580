Title and cover page
Solent University
Faculty of Business, Law and Digital Technologies
B.Sc. in Computing, 2024

Individual Assignment .

Course Title: Advanced Database System, QHO541.
Author: 10184580
Date: 11.06.2024	
Git repository: https://github.com/Sonianupur/MongoDBProject.
Hosted web application:

Introduction:
For the full stack web development project, it  has been  chosen to create a recipe-sharing website that focuses primarily on Bengali dishes, tailored for an audience in Western countries. The site aims to introduce and celebrate the rich culinary heritage of Bangladesh, which often falls under the umbrella of Indian cuisine in the West. This project is inspired by the global popularity of South Asian dishes, particularly in countries like the UK where Chicken Tikka Masala is often regarded as the national dish. The love for Bangladeshi cuisine is evident, and this project seeks to bridge the gap by providing authentic recipes and fostering a community of food enthusiasts.
(NationalCurryWeek, 2024).

 
High-Level Overview of the Recipe Sharing Website:
System Functionality:
The system is built using Node.js, Express, and MongoDB, and it uses EJS for templating.

Datastores:
MongoDB: This NoSQL database is used to store user data and recipe information [MongoDB data screenshot](image.png).
 It includes two primary collections: users and recipes.

User Collection: Stores user information such as first name, last name, email, and hashed passwords [users data screenshot](image-5.png).
Recipe Collection: Stores recipe details including title, ingredients, instructions, image name, and cleaned ingredients.[recipies data screenshot](image-4.png).
File Systems: Used to serve static files such as images, CSS, and JavaScript ![static files folder structure.](image-7.png).

Media Data Stores: Images associated with recipes are stored as file paths in the database, pointing to their location in the file system.![image data stores](image-8.png)

Key Views and Interfaces:
Home Page: An overview of the website with links to key sections such as login, signup, and recipe lists.
Signup Page: A form for new users to create an account.
Login Page: A form for existing users to log in.
Recipe List Page: Displays a paginated list of all recipes.
Recipe Detail Page: Shows detailed information about a specific recipe.
Add/Edit Recipe Page: Forms for adding a new recipe or editing an existing one.
Community Favourite Page: Highlights recipes that are popular within the community.
Contact Page: Provides a form for users to contact the site administrators or support team.
FAQ Page: Lists frequently asked questions and their answers to help users find information quickly.
Healthy Options Page: Showcases recipes that are considered healthy or provide healthier alternatives.
Modern Twist Page: Features traditional recipes with a modern twist.
Header: Common header file included in multiple pages to maintain a consistent navigation bar.

Code overview:
app.js:
This is the main entry point for the application. It sets up the Express server, connects to MongoDB, configures middleware, and defines routes for different parts of the application.
user.js: Defines the schema for user documents in MongoDB using Mongoose.
recipe.js: Defines the schema for recipe documents in MongoDB using Mongoose.
authorization.js: Middleware to authenticate users using JWT tokens.
users.js: Routes for user authentication, including signup, login, and logout.
recipes.js: Routes for managing recipes, including creating, reading, updating, and deleting recipes.

Key Design Decisions:

1. Choice of Technology Stack:
Node.js and Express:
Reasoning: Node.js, coupled with Express, is highly efficient for building fast and scalable network applications. Its non-blocking, event-driven architecture makes it ideal for handling multiple requests simultaneously, which is crucial for a web application like a recipe-sharing platform that may experience high traffic.
Benefits: Fast performance, scalability, and a large ecosystem of middleware and libraries.

MongoDB:
Reasoning: MongoDB is a NoSQL database that is highly flexible and allows for rapid development due to its schema-less nature. It is particularly suitable for applications that require a dynamic and scalable data model.
Benefits: Flexible schema design, scalability, and ease of integration with Node.js using Mongoose.

2. Use of Mongoose for MongoDB Integration
Reasoning: Mongoose provides a straightforward, schema-based solution to model application data. It includes built-in type casting, validation, query building, and business logic hooks.
Benefits: Simplifies the interaction with MongoDB by providing a structured and easy-to-use API. It also helps maintain the integrity of the data through validation and schema definitions.

3. Authentication with JWT
Reasoning: JSON Web Tokens (JWT) provide a stateless authentication mechanism that is both secure and scalable. By using JWT, the application can avoid the complexity of session management and instead rely on a token-based approach where the client stores the token.
Benefits: Enhanced security, scalability, and ease of integration with single-page applications (SPAs).

4. Use of EJS for Templating
Reasoning: EJS (Embedded JavaScript) is a simple templating engine that allows embedding JavaScript code directly within the HTML. This makes it easy to dynamically generate HTML pages on the server-side based on the data from the database.
Benefits: Ease of use, straightforward syntax, and seamless integration with Express.

5. RESTful API Design
Reasoning: Designing the application with RESTful principles ensures that the API is stateless, has a clear structure, and adheres to standard HTTP methods (GET, POST, PUT, DELETE). This makes the API intuitive and easy to use for developers.
Benefits: Consistent and predictable API design, ease of use, and scalability.

6. Middleware for Security and Parsing
body-parser and cookie-parser:
Reasoning: These middleware components are essential for parsing incoming request bodies and cookies. body-parser handles JSON and URL-encoded form submissions, while cookie-parser parses cookies attached to client requests.
Benefits: Simplifies request handling and enhances security by managing cookies effectively.

method-override:
Reasoning: This middleware allows the use of HTTP verbs such as PUT and DELETE in places where the client only supports POST and GET methods.
Benefits: Enables the application to adhere to RESTful principles even when the client has limitations.

7. File System for Static Assets
Reasoning: Serving static files such as images, CSS, and JavaScript from the server is necessary for a web application. Using Expressâ€™s built-in middleware to serve static assets ensures efficient handling and caching.
Benefits: Improved performance and better user experience due to faster load times.

8. User Experience Considerations
Responsive Design:
Reasoning: Ensuring that the website is accessible and usable on various devices and screen sizes enhances the user experience.
Benefits: Wider reach and better engagement from users across different platforms.

Pagination for Recipe Lists:
Reasoning: Implementing pagination for recipe lists prevents overwhelming the user with too much information at once and improves the performance by loading only a subset of data at a time.
Benefits: Enhanced user experience and reduced server load.

Database Design:
Database Entities:
In this project, MongoDB is used as the database. MongoDB is a NoSQL database, which means it uses a flexible, document-oriented approach rather than the rigid table-based structure of SQL databases. Here are the primary entities in the database and their schemas:User and 
Recipe.

User Schema:
The User entity stores information about users who can sign up and log in to the application.[User Schema code](image-1.png).
name: First name of the user.
lname: Last name of the user.
email: Email address of the user, must be unique.
password: Hashed password of the user.

Recipe Schema:
The Recipe entity stores information about the recipes shared by users.[recipe scheme code](image-2.png).
Title: Title of the recipe.
Ingredients: List of ingredients required for the recipe.
Instructions: Step-by-step instructions to prepare the recipe.
Image_Name: Name of the image file associated with the recipe.
Cleaned_Ingredients: List of cleaned ingredients (processed or simplified names).
createdAt: Timestamp of when the recipe was created.
Entity Relationship Diagram (ERD)
[Entity diagram](image-3.png)

Differences Between NoSQL and SQL Databases:
Schema Flexibility:
SQL: Uses a fixed schema. Changes to the schema (e.g., adding a new column) require modifying the table structure, which can be complex and time-consuming.
NoSQL: Schema-less, allowing for flexible and dynamic changes to the data model. Documents can have different fields and structures.

Data Storage:
SQL: Stores data in tables with rows and columns.
NoSQL: Stores data in collections of documents (usually JSON or BSON), key-value pairs, wide-column stores, or graph databases.

Relationships:
SQL: Supports complex relationships (one-to-one, one-to-many, many-to-many) using foreign keys and join operations.
NoSQL: Typically avoids complex joins and relationships. Instead, related data is often denormalized and embedded within documents to improve read performance.

Scalability:
SQL: Vertically scalable (scale-up), meaning you can add more power (CPU, RAM) to a single server.
NoSQL: Horizontally scalable (scale-out), meaning you can add more servers to distribute the load.

Transactions:
SQL: Strong support for ACID (Atomicity, Consistency, Isolation, Durability) transactions, ensuring reliable and consistent transactions.
NoSQL: Some NoSQL databases provide eventual consistency and may not fully support ACID transactions, although many modern NoSQL databases have improved in this area.

Use Cases:
SQL: Suitable for applications requiring complex queries and transactions, such as financial systems, ERP, and CRM.
NoSQL: Suitable for applications requiring flexible schema design, high performance, and scalability, such as content management systems, real-time analytics, and IoT.

The decision to use MongoDB for this project is driven by the need for a flexible schema and the ability to handle unstructured data efficiently. The document-oriented approach of MongoDB aligns well with the nature of the data (user profiles and recipes) and supports rapid development and scalability.

Security and Scalability:
Security:

Authentication with JWT:
Description: The application uses JSON Web Tokens (JWT) for user authentication. Upon successful login, a token is generated and stored in the user's cookies.
Benefits: JWTs are stateless and secure, making them ideal for distributed systems. They ensure that each request to protected routes is authenticated without needing to store session data on the server.

Password Hashing:
Description: User passwords are hashed using bcrypt before being stored in the database.
Benefits: Hashing passwords adds a layer of security, ensuring that even if the database is compromised, the actual passwords are not exposed. bcrypt also handles salting, making hash-based attacks more difficult.

HTTPS:
Description: The application should be served over HTTPS to encrypt data transmitted between the client and server.
Benefits: Encrypting data in transit prevents man-in-the-middle attacks, ensuring that sensitive information like login credentials remains secure.

Input Validation and Sanitization:
Description: User inputs are validated and sanitized to prevent malicious data from entering the system.
Benefits: This practice helps protect against common web vulnerabilities such as SQL injection and cross-site scripting (XSS).

Authorization Middleware:
Description: Middleware functions like verifyAuthorization are used to protect routes that require authentication.
Benefits: Ensures that only authenticated users can access certain routes, enhancing the security of sensitive operations like creating, updating, or deleting recipes.

Error Handling:
Description: Proper error handling mechanisms are in place to handle unexpected issues gracefully and securely.
Benefits: Prevents the application from exposing sensitive information and provides meaningful error messages to users.

Scalability

Horizontal Scaling with MongoDB:
Description: MongoDB is designed to scale out by distributing data across multiple servers (sharding).
Benefits: Allows the application to handle increased load by adding more servers, making it suitable for high-traffic applications.

Node.js Non-Blocking I/O:
Description: Node.js uses an event-driven, non-blocking I/O model.
Benefits: This architecture is efficient and scalable, capable of handling many concurrent 
connections without significant performance degradation.

Load Balancing:
Description: Deploying the application behind a load balancer can distribute incoming requests across multiple instances of the application.
Benefits: Improves fault tolerance and ensures that no single server bears too much load, enhancing the application's scalability.

Containerization with Docker:
Description: Containerizing the application using Docker can simplify deployment and scaling.
Benefits: Containers ensure consistent environments across development, testing, and production, and they can be easily replicated to handle increased traffic.

Microservices Architecture:
Description: Splitting the application into smaller, independent services that communicate over APIs can enhance scalability.
Benefits: Each microservice can be scaled independently based on its load, leading to more efficient resource utilization.

Caching:
Description: Implementing caching mechanisms (e.g., Redis, Memcached) can reduce the load on the database by storing frequently accessed data in memory.
Benefits: Improves application performance and scalability by reducing the number of database queries for repeated requests.

Auto-scaling on Cloud Platforms:
Description: Deploying the application on cloud platforms (e.g., AWS, Azure, Google Cloud) that support auto-scaling.
Benefits: Automatically adjusts the number of running instances based on the current load, ensuring optimal resource usage and cost-efficiency.

By implementing robust security measures and designing the application with scalability in mind, the recipe-sharing website is well-prepared to handle both current and future demands. The use of JWT for authentication, bcrypt for password hashing, and HTTPS for secure communication ensures that user data is protected. Meanwhile, the application's architecture, leveraging Node.js, MongoDB, and potential cloud services, supports efficient scaling to accommodate growing user bases and traffic.

CRUD Operations and Database Justification:
CRUD Operations Overview:
The recipe-sharing website exposes CRUD operations for managing users and recipes. These operations are fundamental for interacting with the database, allowing the application to create, read, update, and delete records. Below is an overview of the CRUD operations implemented:

Create:
User Registration: Allows new users to sign up and have their details stored in the MongoDB database.
Add Recipe: Authenticated users can add new recipes to the database.

Read:
View Recipe List: Users can view a paginated list of recipes.
View Recipe Details: Users can view detailed information about a specific recipe.
User Login: Allows users to log in and retrieve their details for authentication.

Update:
Edit Recipe: Authenticated users can update the details of their recipes.

Delete:
Delete Recipe: Authenticated users can delete their recipes from the database.
User Logout: Users can log out, which effectively clears their session.

Database Justification:
The primary database used for this project is MongoDB, specifically MongoDB Atlas, a fully managed cloud database service. Below are the reasons for choosing MongoDB and the potential consideration for combining databases:

MongoDB (NoSQL Database):

Schema Flexibility:
Reasoning: MongoDB's schema-less design allows for flexible and dynamic data models. This is crucial for the recipe-sharing application, where the data structure can vary widely between different recipes and user profiles.
Benefits: Easily accommodates changes and additions to the data model without requiring complex migrations.

Scalability:
Reasoning: MongoDB is designed for horizontal scalability, allowing it to handle large volumes of data and high traffic loads by distributing data across multiple servers (sharding).
Benefits: Ensures that the application can scale efficiently as the user base grows.

Ease of Use with Node.js:
Reasoning: MongoDB integrates seamlessly with Node.js through the Mongoose library, providing a simple and intuitive API for data interaction.
Benefits: Simplifies development and reduces the complexity of database operations, allowing for faster development cycles.

Geospatial Data Support:
Reasoning: MongoDB supports geospatial indexes and queries, which can be useful if the application evolves to include location-based features such as finding nearby restaurants or events related to Bengali cuisine.
Benefits: Adds flexibility for future feature expansion without needing to change the underlying database.

Combining with SQL Databases (Consideration):
While the current implementation focuses solely on MongoDB, there are scenarios where combining it with an SQL database might be beneficial:

Complex Transactions:
Scenario: If the application requires complex multi-row transactions, an SQL database could complement MongoDB. SQL databases are inherently strong in handling ACID transactions.
Benefit: Ensures data consistency and integrity in scenarios requiring complex transactional operations.

Relational Data:
Scenario: If the application evolves to include features requiring complex relationships (many-to-many relationships) that are more naturally modeled in an SQL database.
Benefit: Provides a more structured approach to handling relational data, which can simplify certain queries and operations.

Justification Summary
MongoDB was chosen primarily for its flexibility, scalability, and seamless integration with Node.js. Its ability to handle dynamic and unstructured data makes it ideal for the recipe-sharing application, where recipe structures can vary significantly. MongoDB Atlas provides a managed cloud service, reducing the operational overhead and ensuring high availability and security.

Considering SQL databases could be justified if future requirements include complex transactions or intricate relational data that would benefit from a more structured schema. This would allow leveraging the strengths of both NoSQL and SQL databases, providing a balanced approach to handling diverse data needs.

The choice of MongoDB for this project is well-suited to the application's requirements, offering the flexibility and scalability needed to handle dynamic data and growth. However, the potential integration of SQL databases can provide additional benefits for specific use cases, ensuring that the application remains robust, secure, and adaptable to future demands. By implementing comprehensive CRUD operations, the application ensures efficient and effective data management, providing a seamless experience for users.


Conclusion:
The development of the recipe-sharing website has been an extensive and rewarding journey. The primary goal was to create a platform that allows users to discover, share, and enjoy authentic Bengali dishes in Western countries. This project leveraged a modern tech stack, including Node.js, Express, MongoDB, and EJS, to create a robust and scalable application.

Throughout this project, several key design decisions were made to ensure the application is secure, efficient, and user-friendly. Implementing JWT for authentication, bcrypt for password hashing, and HTTPS for secure communication has fortified the application's security. Using MongoDB allowed for a flexible and dynamic schema design, which is crucial for the evolving nature of recipe data.

The use of middleware for security, validation, and parsing requests enhanced the application's robustness. Additionally, employing RESTful principles ensured a clean and maintainable API design, making the system intuitive and easy to extend.

Reflection:
The journey of developing this project has been a significant learning experience, offering valuable insights into full-stack web development. Here are some key reflections:

Understanding the Tech Stack:
Challenge: One of the initial challenges was gaining a deep understanding of the chosen tech stack, particularly the integration of Node.js with MongoDB and the use of Express for routing.
Learning: Through extensive documentation review and hands-on practice, I gained proficiency in setting up and configuring these technologies, which will be beneficial for future projects.

Security Practices:
Challenge: Ensuring the application was secure required careful consideration and implementation of best practices.
Learning: Implementing JWT, password hashing, and HTTPS provided practical experience in enhancing application security, which is critical in web development.

Scalability Considerations:
Challenge: Designing the system to be scalable involved understanding the principles of horizontal scaling, load balancing, and efficient database usage.
Learning: This project highlighted the importance of scalability and provided practical experience in implementing scalable solutions using modern tools and practices.

Database Design:
Challenge: Designing a flexible and efficient database schema that could handle the dynamic nature of recipe data was challenging.
Learning: Leveraging MongoDB's schema-less design offered a significant advantage in handling complex data structures, and the experience gained will be invaluable for future projects involving NoSQL databases.

User Experience:
Challenge: Creating an intuitive and engaging user interface required careful planning and consideration of user needs.
Learning: Using EJS for templating and ensuring responsive design principles were applied, 
The author was able to create a user-friendly interface. This experience underscored the importance of user experience in application design.

Project Management:
Challenge: Managing the various aspects of the project, from development to testing and deployment, required effective planning and time management.
Learning: The project reinforced the value of structured project management practices and highlighted areas for improvement in future projects, such as more rigorous testing and documentation.

Final Thoughts:
The completion of this project marks a significant milestone in my journey as a web developer. It provided a comprehensive understanding of full-stack development and reinforced the importance of security, scalability, and user experience. The challenges faced and the solutions implemented have not only enhanced my technical skills but also prepared me for tackling more complex projects in the future.




















